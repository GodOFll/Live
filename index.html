<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>دستیار صوتی زنده با Gemini 1.5 Pro</title>
    <style>
        body { font-family: 'Vazirmatn', sans-serif; background-color: #121212; color: #e0e0e0; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; }
        #chat-container { width: 80%; max-width: 700px; height: 70vh; border: 1px solid #444; border-radius: 8px; overflow-y: auto; padding: 20px; background-color: #1e1e1e; margin-bottom: 20px; display: flex; flex-direction: column; }
        .message { margin-bottom: 15px; padding: 10px 15px; border-radius: 18px; max-width: 80%; line-height: 1.6; }
        .user-message { background-color: #3b3b3b; align-self: flex-start; }
        .gemini-message { background-color: #004d40; align-self: flex-end; }
        #status { margin-bottom: 15px; font-size: 1.1em; text-align: center; min-height: 25px; transition: color 0.3s ease; }
        #input-container { width: 80%; max-width: 700px; display: flex; }
        #text-input { flex-grow: 1; padding: 10px; border-radius: 5px; border: 1px solid #555; background-color: #2c2c2c; color: #e0e0e0; font-size: 1em; }
        button { padding: 10px 15px; margin-right: 10px; border: none; background-color: #00796b; color: white; border-radius: 5px; cursor: pointer; transition: background-color 0.2s; }
        button:hover { background-color: #004d40; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="status">در حال اتصال به سرور...</div>
    <div id="chat-container"></div>
    <div id="input-container">
        <input type="text" id="text-input" placeholder="اینجا تایپ کنید یا صحبت کنید...">
        <button id="send-button">ارسال متن</button>
    </div>

    <script>
        const statusDiv = document.getElementById('status');
        const chatContainer = document.getElementById('chat-container');
        const textInput = document.getElementById('text-input');
        const sendButton = document.getElementById('send-button');

        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const WEBSOCKET_URL = `${wsProtocol}//${window.location.host}/ws`;
        console.log(`درحال اتصال به WebSocket در آدرس: ${WEBSOCKET_URL}`);

        const TARGET_SAMPLE_RATE = 16000;
        const OUTPUT_SAMPLE_RATE = 24000;

        let websocket;
        let audioContext;
        let audioProcessor;
        let microphoneStream;
        
        let audioQueue = [];
        let isPlaying = false;
        let outputAudioContext;

        function addMessage(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            messageDiv.textContent = text;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function connectWebSocket() {
            websocket = new WebSocket(WEBSOCKET_URL);
            websocket.binaryType = 'arraybuffer';

            websocket.onopen = () => {
                statusDiv.textContent = 'متصل شد! آماده دریافت صدا...';
                statusDiv.style.color = '#4caf50';
                console.log('WebSocket متصل شد.');
                startMicrophone();
            };

            websocket.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    if (event.data.startsWith('TEXT: ')) {
                        const text = event.data.substring(6);
                        console.log("متن دریافتی از Gemini:", text);
                        addMessage(text, 'gemini');
                    } else if (event.data.startsWith('Error: ')) {
                        const errorText = event.data.substring(7);
                        statusDiv.textContent = `خطا: ${errorText}`;
                        statusDiv.style.color = '#f44336';
                        console.error("خطای دریافتی از سرور:", errorText);
                    } else {
                        console.warn("پیام متنی ناشناخته:", event.data);
                    }
                } else {
                    const pcmData = new Int16Array(event.data);
                    audioQueue.push(pcmData);
                    if (!isPlaying) {
                        playAudioQueue();
                    }
                }
            };

            websocket.onclose = (event) => {
                statusDiv.textContent = 'ارتباط قطع شد. تلاش برای اتصال مجدد...';
                statusDiv.style.color = '#f44336';
                console.log(`WebSocket قطع شد: Code=${event.code}, Reason=${event.reason}`);
                stopMicrophone();
                setTimeout(connectWebSocket, 3000); // تلاش برای اتصال مجدد
            };

            websocket.onerror = (error) => {
                statusDiv.textContent = 'خطا در ارتباط WebSocket.';
                statusDiv.style.color = '#f44336';
                console.error('خطای WebSocket:', error);
            };
        }
        
        function stopMicrophone() {
            if (microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
                microphoneStream = null;
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(console.error);
                audioContext = null;
            }
        }
        
        async function playAudioQueue() {
            if (audioQueue.length === 0) {
                isPlaying = false;
                return;
            }
            isPlaying = true;

            if (!outputAudioContext || outputAudioContext.state === 'closed') {
                outputAudioContext = new AudioContext({ sampleRate: OUTPUT_SAMPLE_RATE });
            }

            const pcmChunk = audioQueue.shift();
            const float32Array = new Float32Array(pcmChunk.length);
            for (let i = 0; i < pcmChunk.length; i++) {
                float32Array[i] = pcmChunk[i] / 32768.0;
            }

            const audioBuffer = outputAudioContext.createBuffer(1, float32Array.length, OUTPUT_SAMPLE_RATE);
            audioBuffer.copyToChannel(float32Array, 0);

            const source = outputAudioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(outputAudioContext.destination);
            source.start();
            source.onended = playAudioQueue;
        }

        function sendTextInput() {
            const text = textInput.value;
            if (text.trim() && websocket && websocket.readyState === WebSocket.OPEN) {
                addMessage(text, 'user');
                websocket.send(text);
                textInput.value = '';
            }
        }

        sendButton.addEventListener('click', sendTextInput);
        textInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendTextInput(); });

        const audioProcessorCode = `
        class AudioProcessor extends AudioWorkletProcessor {
            constructor() {
                super();
                this.bufferSize = 2048;
                this.buffer = new Int16Array(this.bufferSize);
                this.bufferIndex = 0;
            }
            process(inputs) {
                const inputChannel = inputs[0][0];
                if (inputChannel) {
                    for (let i = 0; i < inputChannel.length; i++) {
                        this.buffer[this.bufferIndex++] = Math.max(-1, Math.min(1, inputChannel[i])) * 0x7FFF;
                        if (this.bufferIndex === this.bufferSize) {
                            this.port.postMessage(this.buffer.buffer.slice(0));
                            this.bufferIndex = 0;
                        }
                    }
                }
                return true;
            }
        }
        registerProcessor('audio-processor', AudioProcessor);
        `;

        const blob = new Blob([audioProcessorCode], { type: 'application/javascript' });
        const audioProcessorUrl = URL.createObjectURL(blob);

        async function startMicrophone() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('مرورگر شما از API دسترسی به میکروفون پشتیبانی نمی‌کند.');
                return;
            }
            try {
                microphoneStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { sampleRate: TARGET_SAMPLE_RATE, channelCount: 1, echoCancellation: true, noiseSuppression: true } 
                });
                
                audioContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
                await audioContext.audioWorklet.addModule(audioProcessorUrl);
                
                const source = audioContext.createMediaStreamSource(microphoneStream);
                audioProcessor = new AudioWorkletNode(audioContext, 'audio-processor');

                audioProcessor.port.onmessage = (event) => {
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        websocket.send(event.data);
                    }
                };

                source.connect(audioProcessor);

                statusDiv.textContent = 'میکروفون فعال است. صحبت کنید...';
                statusDiv.style.color = '#4caf50';
                console.log("میکروفون با موفقیت فعال و متصل شد.");

            } catch (err) {
                statusDiv.textContent = 'خطا در دسترسی به میکروفون. لطفاً اجازه دهید.';
                statusDiv.style.color = '#f44336';
                console.error("خطا در دسترسی به میکروفون:", err);
                alert("برای استفاده از این برنامه، لطفاً دسترسی به میکروفون را مجاز کنید و صفحه را رفرش کنید.");
            }
        }
        
        // شروع کل فرآیند
        connectWebSocket();
    </script>
</body>
</html>
